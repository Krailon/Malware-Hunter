#Malware-Hunter
==============
I got tired of manually sifting through spam email and digging around search engines, thus Malware Hunter was born.
Planned features include:
- POP3/OAUTH email fetching for harvesting spam links
- Automatic redirect following
- Limited Javascript deobfuscation
- Custom pattern-matching format for identifying threat types
- High-level binary threat analysis to decide whether samples should be submitted to Malwr

##Custom Pattern-Matching Format
Patterns are essentially key-value pairs, separated by the delimiter **?:**. The first part is used to identify
the type of match and the object to find. The format of the second part depends on what type of match the first part specifies, as outlined below.

####HTML
HTML tags must start with an opening angle bracket, as per standard HTML. The second part specifies attributes to match. Attributes in tags can be in any order, so the underlying code checks each attribute with a separate Regular Expression to achieve relative positional independence. No closing angle bracket should be included.

Each attribute can be specified in a number of ways that build upon each other. An attribute specified by name alone will match the existence of that attribute in the tag. Adding an equals character after the attribute name will match that attribute only if it has a non-empty value. Adding a further value after the equals character (without quotes, the Regular Expressions take care of those) will only match that attribute if it has the specified value.

Examples:
- <form?:action,method=post
- <input?:type=password
- <meta?:http-equiv=refresh,content=

####Javascript
Anything that's not recognized as an HTML tag (in other words, anything not starting with an angle bracket)
is assumed to be Javascript (at this time, but subject to change). Javascript patterns function very similarly to the HTML patterns, but can be used as generic patterns as well. The first part usually matches an object. The second part usually matches an attribute reference (location.href) or a method call (location.replace()).

Currently, with Javascript patterns, the second part is checked for an equals character, which implies only matching if a value is set for that attribute (null and undefined don't count). The second part is also checked for a set of parentheses (denoting a method call). Patterns matching method calls can specify between their parentheses either a single number (to match only if the call has that number of arguments passed to it) or a list of values (including **?** to match any value).

Examples:
- location.?:replace(1),href=
- $(location).?:attr(href,?)

####Future Plans
Eventually I need to be able to match binary patterns in executable code to do some basic static analysis of harvested malware samples. This will require a third type of pattern, most likely specified by a series of encoded bytes taking the form "\xnn\xnn...". The semantics of machine code is quite different than relatively natural languages like HTML and Javascript. The format of this third pattern will most likely be strange but as long as it allows me to specify more dynamic patterns it should be highly useful.
